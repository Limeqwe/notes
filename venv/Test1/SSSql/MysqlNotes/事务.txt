事务
    一个事务其实就是一个完整的业务逻辑

    什么是一个完整的业务逻辑？
        假设转账，从A账户向B账户中转账1w
        将A账户的钱减去1w
        将B账户的钱加上1w
        这就是一个完整的业务逻辑

        以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分
        这两个update语句要求必须同时成功或者失败，这样才能保证钱是正确的

    只有DML语句才会有事务这一说，其它语句和事务无关！！！
    insert
    delete
    update
    只有以上的三个语句和事务有关系 其它没有关系

    因为 只有以上操作是数据库表中的增删改
    只要你的操作一旦设计到数据的增删改，那么就一定要考虑安全问题

    数据安全第一位
    mysql默认是自动提交
    start transaction 关闭mysql的自动提交机制关闭

    事物包括4个特性
    A 原子性
        说明事务是最小的工作单元，不可再分

    C 一致性
        所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性

    I：隔离性
        A事务和B事务之间有一定的隔离
        教室A和教室B之间也有一道墙，这道墙就是隔离性

    D：持久性
        事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据保存到硬盘上!

    事务和事务之间的隔离级别有哪些
    读未提交: read uncommitted（没有提交就读到了）
        事务A可以读取到事务B未提交的数据
        这种隔离级别存在的问题就是 ：
            脏读现象 称为读到了脏数据 (一般都是理论上的，大多数的数据库隔离级别都是二挡岂不)
    读已提交: read committed（提交之后才能读到）
        事务A只能读取到事务B提交之后的数据
            这种隔离级别 解决了脏读现象
        存在
            不可重复读取数据(在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是四条，3不等于4称为不可重复读取)

    可重复读: repeatable read《提交之后就读不到了，永远读到的都是刚开始事务时》
        事务A开启之后，不管多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。
    序列化/串行化: serializable
        效率最低 解决了所有的问题
        这种隔离级别表示事务排毒，不能并发
        synchronized 线程同步（事务同步）
        每一次读取到的数据都是最真实的，并且效率是最低的